---
title: Development Roadmap
description: FerrisDB's journey from components to distributed database
sidebar:
  badge:
    text: JOURNEY
    variant: note
---

import { Aside, Card, CardGrid, Tabs, TabItem, Badge } from "@astrojs/starlight/components";
import Stats from "../../../components/Stats.astro";

<Aside type="tip" title="Journey Documentation">
  This roadmap shows our learning journey, not promises. We're building to understand, discovering
  what works through implementation. Follow our [blog](/blog/) to see real-time progress!
</Aside>

**Current Status**: <Stats />

## Our Building Journey

<Tabs>
  <TabItem label="‚úÖ What We've Built">
    <Badge text="IMPLEMENTED" variant="success" />
    ### Storage Components - **Write-Ahead Log** - Binary format with CRC32 checksums - **MemTable**
    - Concurrent skip list with MVCC timestamps - **SSTable Writer** - Can persist sorted data to
    disk ### Learning Outputs - **6 Blog Posts** - Documenting our daily journey - **1 Tutorial** -
    Build your own key-value store - **~2,000 lines** - Of actual implementation code - **25+
    Tests** - Showing how components work
  </TabItem>

<TabItem label="üöß What We're Building">
  <Badge text="IN PROGRESS" variant="caution" />
  ### Current Focus - **SSTable Reader** - Make it actually read files - **Storage Engine** -
  Connect components together - **Basic Operations** - Simple get/put interface ### This Week's
  Goals - Complete SSTable reader implementation - Write integration tests - Document learning in
  blog posts
</TabItem>

  <TabItem label="üìã What We Dream About">
    <Badge text="FUTURE EXPLORATION" variant="note" />
    ### Near Future (Months) - Compaction strategies - Block cache for performance - Bloom filters
    for efficiency - Compression support ### Far Future (Someday) - Transactions with MVCC -
    Distribution with Raft - Network protocol - Production optimizations
  </TabItem>
</Tabs>

## Phase 1: Storage Foundation üèóÔ∏è

**Goal**: Understand how databases persist data reliably

<CardGrid>
  <Card title="Completed ‚úÖ" icon="approve-check">
    - WAL for durability
    - MemTable for fast writes
    - SSTable writer
    - Binary encoding
    - Error handling patterns
  </Card>

<Card title="In Progress üöß" icon="rocket">
  - SSTable reader - Component integration - Storage engine API - More comprehensive tests
</Card>

  <Card title="Next Up üìã" icon="document">
    - Compaction logic
    - Manifest files
    - Recovery process
    - Performance metrics
  </Card>
</CardGrid>

## Phase 2: Database Operations üîß

**Goal**: Make it actually work like a database

### What This Means

- `get(key) -> Option<value>`
- `put(key, value) -> Result<()>`
- `delete(key) -> Result<()>`
- `scan(start, end) -> Iterator`

### Learning Challenges

- How to integrate components efficiently
- When to flush MemTable to disk
- How to merge multiple data sources
- Error handling across layers

<Aside type="note">
  Each operation seems simple but requires coordinating multiple components. This is where we'll
  really understand database complexity!
</Aside>

## Phase 3: Advanced Storage üìä

**Goal**: Understand optimization techniques

### Topics to Explore

- **Compaction**: Why and how databases merge files
- **Caching**: Block cache design and trade-offs
- **Bloom Filters**: Probabilistic data structures
- **Compression**: Space vs. CPU trade-offs

### Why These Matter

Real databases spend most complexity here. Understanding these optimizations teaches:

- Why databases make certain trade-offs
- How to think about system performance
- When optimization actually matters

## Phase 4: Transactions üîÑ

**Goal**: ACID properties and isolation levels

<Aside type="caution">
  This is where things get really interesting (and complex). We'll learn why distributed systems
  papers are full of transaction algorithms!
</Aside>

### Learning Path

1. **MVCC Basics** - We already have timestamps!
2. **Snapshot Isolation** - Read consistency
3. **Write Conflicts** - Detection and resolution
4. **Transaction Manager** - Coordinating it all

## Phase 5: Distribution üåê

**Goal**: Scale beyond a single machine

### The Dream

- **Consensus**: Raft protocol implementation
- **Sharding**: Data distribution strategies
- **Replication**: Fault tolerance
- **Coordination**: Distributed transactions

### The Reality

This might remain a dream, but planning it teaches us about:

- CAP theorem in practice
- Network partition handling
- Consistency vs. availability trade-offs

## How We Work

<CardGrid>
  <Card title="Human Assigns" icon="user">
    "Let's implement SSTable reader"
  </Card>

<Card title="AI Implements" icon="robot">
  Code + explanation of decisions
</Card>

<Card title="Human Reviews" icon="magnifier">
  Questions lead to understanding
</Card>

  <Card title="Both Learn" icon="puzzle">
    Document insights in blog
  </Card>
</CardGrid>

## Success Metrics

### What Success Looks Like

- **Understanding** > Performance
- **Learning** > Features
- **Journey** > Destination

### How We Measure

- Blog posts documenting insights
- Tutorials teaching others
- Code that explains itself
- Questions that lead to "aha!" moments

## Get Involved

<Card title="Follow the Journey" icon="telescope">
  - **Read**: [Our blog](/blog/) for daily progress - **Learn**:
  [Tutorials](/tutorials/01-key-value-store/) to build your own - **Explore**: [Current
  code](/reference/current-implementation/) with comments - **Contribute**:
  [GitHub](https://github.com/ferrisdb/ferrisdb) - questions welcome!
</Card>

## The Honest Truth

We don't know if we'll build a distributed database. We might get stuck on transactions. We might
discover that compaction is harder than expected. **That's the point.**

This roadmap isn't a promise - it's a learning adventure. Join us to discover:

- How databases really work
- Why certain designs win
- What makes systems programming hard
- How human-AI collaboration can tackle complex problems

---

<p style="text-align: center; margin-top: 2rem;">
  <em>The journey of a thousand miles begins with a single `cargo test`</em>
</p>
