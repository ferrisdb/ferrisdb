---
title: First Queries Tutorial
description: Get hands-on with FerrisDB - learn database concepts by running your first queries
---

import { Card, CardGrid, Tabs, TabItem, Aside, Steps } from "@astrojs/starlight/components";

<Aside type="note" title="Learning Project">
  This tutorial focuses on understanding database concepts through simple examples. FerrisDB is an
  educational project, not production-ready software.
</Aside>

## What You'll Learn

By the end of this tutorial, you'll understand:

- How databases store data in memory (MemTable)
- How they ensure durability (Write-Ahead Log)
- Why databases use specific data structures (Skip Lists)
- The basics of LSM-tree storage engines

## Prerequisites

<Steps>

1. **Install Rust** (if you haven't already)

   ```bash
   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
   source ~/.cargo/env
   ```

2. **Clone FerrisDB**

   ```bash
   git clone https://github.com/ferrisdb/ferrisdb
   cd ferrisdb
   ```

3. **Run the tests** (make sure everything works)
   ```bash
   cargo test
   ```

</Steps>

## Your First Database Operations

Let's start with the most basic operations: storing and retrieving data.

<Tabs>
  <TabItem label="Simple Set/Get">
    ```rust
    // This is what we're building toward
    use ferrisdb_storage::StorageEngine;
    
    fn main() -> Result<(), Box<dyn std::error::Error>> {
        let db = StorageEngine::new("./data")?;
        
        // Store a value
        db.set(b"name".to_vec(), b"Alice".to_vec())?;
        
        // Retrieve it
        let value = db.get(b"name")?;
        println!("Retrieved: {:?}", String::from_utf8(value.unwrap()));
        
        Ok(())
    }
    ```
  </TabItem>
  
  <TabItem label="What's Actually Happening">
    ```rust
    // Under the hood, this is what happens:
    
    // 1. Write to WAL first (durability)
    wal.append(LogEntry {
        sequence_number: 1,
        key: b"name".to_vec(),
        value: Some(b"Alice".to_vec()),
        timestamp: SystemTime::now(),
    })?;
    
    // 2. Then store in MemTable (fast access)
    memtable.set(b"name".to_vec(), b"Alice".to_vec())?;
    
    // 3. When reading, check MemTable first
    if let Some(value) = memtable.get(b"name") {
        return Ok(Some(value));
    }
    // 4. If not found, check SSTables on disk
    ```
  </TabItem>
</Tabs>

## Understanding the Storage Engine

Let's look at the actual code we've built and understand why it's designed this way.

### The MemTable: In-Memory Storage

<Tabs>
  <TabItem label="Why Skip Lists?">
    ```rust
    // ferrisdb-storage/src/memtable/mod.rs
    pub struct MemTable {
        // Why Arc<SkipList> instead of HashMap?
        skiplist: Arc<SkipList>,
        memory_usage: AtomicUsize,
        max_size: usize,
    }
    
    impl MemTable {
        pub fn set(&self, key: Vec<u8>, value: Vec<u8>) -> Result<()> {
            // Skip lists provide:
            // 1. O(log n) operations like a balanced tree
            // 2. Lock-free concurrent access
            // 3. Sorted iteration (needed for range queries)
            self.skiplist.insert(key, value);
            
            // Track memory usage for when to flush to disk
            let size = key.len() + value.len();
            self.memory_usage.fetch_add(size, Ordering::Relaxed);
            
            Ok(())
        }
    }
    ```
  </TabItem>
  
  <TabItem label="Try It">
    ```bash
    # Look at the actual MemTable implementation
    cat ferrisdb-storage/src/memtable/mod.rs
    
    # Run the MemTable tests to see it in action
    cargo test memtable
    ```
  </TabItem>
</Tabs>

### The Write-Ahead Log: Crash Recovery

<Aside type="tip" title="Why WAL First?">
  The WAL (Write-Ahead Log) is written before the MemTable because if we crash after updating memory
  but before writing to disk, we'd lose data. WAL ensures durability.
</Aside>

<Tabs>
  <TabItem label="WAL Structure">
    ```rust
    // ferrisdb-storage/src/wal/log_entry.rs
    #[derive(Debug, Clone, PartialEq)]
    pub struct LogEntry {
        pub sequence_number: u64,   // For ordering during recovery
        pub key: Vec<u8>,          // What we're storing
        pub value: Option<Vec<u8>>, // None = deletion
        pub timestamp: u64,        // When this happened
    }
    
    // ferrisdb-storage/src/wal/mod.rs
    impl WAL {
        pub fn append(&mut self, entry: LogEntry) -> Result<()> {
            // 1. Serialize the entry
            let serialized = self.serialize_entry(&entry)?;
            
            // 2. Write to file
            self.file.write_all(&serialized)?;
            
            // 3. Force to disk (fsync)
            self.file.sync_all()?;
            
            Ok(())
        }
    }
    ```
  </TabItem>
  
  <TabItem label="Recovery Process">
    ```rust
    // When we restart, we replay the WAL
    impl WAL {
        pub fn recover(path: &str) -> Result<(WAL, Vec<LogEntry>)> {
            let mut entries = Vec::new();
            let file = OpenOptions::new().read(true).open(path)?;
            
            // Read all entries from the log
            while let Ok(entry) = Self::read_entry(&mut file) {
                entries.push(entry);
            }
            
            // These entries get replayed into the MemTable
            Ok((WAL::new(path)?, entries))
        }
    }
    ```
  </TabItem>
</Tabs>

## Hands-On Exercise

Let's trace through what happens when you store and retrieve data:

<Steps>

1. **Look at the storage engine**

   ```bash
   cat ferrisdb-storage/src/storage_engine.rs
   ```

2. **Run a simple example**

   ```bash
   # This will be available once we create the example
   cargo run --example basic_operations
   ```

3. **Examine the files created**

   ```bash
   ls -la ./data/
   # You should see:
   # - wal.log (the write-ahead log)
   # - Any SSTable files (when MemTable flushes)
   ```

4. **Look at the WAL contents**
   ```bash
   # The WAL is binary, but you can see it was written
   hexdump -C ./data/wal.log | head -10
   ```

</Steps>

## Understanding LSM Trees

<CardGrid>
  <Card title="What is an LSM Tree?" icon="forward">
    **Log-Structured Merge Tree** - optimized for write-heavy workloads 1. **Writes** go to MemTable
    (fast) 2. **MemTable flushes** to SSTable when full 3. **SSTables merge** during compaction
    [Deep Dive ‚Üí](/concepts/database-internals/lsm-trees)
  </Card>

  <Card title="Why Not B-Trees?" icon="puzzle">
    B-trees require random writes to disk, which are slow. LSM trees convert random writes into
    sequential writes. [Learn More ‚Üí](/concepts/database-internals/lsm-trees)
  </Card>
</CardGrid>

## What's Next?

<CardGrid>
  <Card title="Understand the Architecture" icon="open-book">
    See how all the pieces fit together [Architecture Overview ‚Üí](/reference/architecture)
  </Card>

<Card title="Read the Blog" icon="rocket">
  Follow our learning journey from day 1 [Development Blog ‚Üí](/blog-overview)
</Card>

<Card title="Dive Deeper" icon="star">
  Explore database internals concepts [Database Concepts ‚Üí](/concepts/database-internals/)
</Card>

  <Card title="See the Code" icon="github">
    Browse the implementation with detailed comments [View Source
    ‚Üí](https://github.com/ferrisdb/ferrisdb)
  </Card>
</CardGrid>

## Key Takeaways

After this tutorial, you should understand:

- ‚úÖ **Durability**: WAL ensures data survives crashes
- ‚úÖ **Performance**: MemTable provides fast access to recent data
- ‚úÖ **Concurrency**: Skip lists allow multiple readers/writers
- ‚úÖ **Storage**: SSTables organize data efficiently on disk
- ‚úÖ **LSM Design**: Why modern databases use this architecture

<Aside type="tip" title="Keep Learning">
  The best way to understand databases is to build one. Even if it's simple, you'll learn more from
  implementation than from reading theory.
</Aside>

## Questions or Issues?

- üí¨ **Ask questions** in GitHub Issues
- üìñ **Read our blog** for detailed explanations
- üîç **Browse the code** - it's designed to be readable
- ü§ù **Follow the collaboration** between human and AI learning

Remember: this is a learning project. The goal is understanding, not optimization!
